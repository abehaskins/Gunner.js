<!DOCTYPE html>

<html>
<head>
  <title>Cannon.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>Cannon.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <pre><code>Cannon.js 0.0.1
(c) 2014 Abraham Haskins
Cannon may be freely distributed under the MIT license.
</code></pre><p>Our main Cannon class which takes the URL of the data we are looking to retreive and manipulate.</p>
<p>For example <code>new Cannon(&quot;http://api.reddit.com/user/unidan/&quot;)</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Cannon = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(url)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h2 id="initial-setup">Initial setup</h2>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              
            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>The URL this Cannon loads data from.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.url = url;</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>The object containing reloader information</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.reloaderStrs = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>The default projectile is <code>&quot;*&quot;</code> i.e. all children of data</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.projectileStr = <span class="hljs-string">"*"</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>All data loaded from URL and reloads, used for <code>Cannon.recoil</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.rawData = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>The total HTTP requests made, used for <code>Cannon.limit</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.fetches = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>The delay (in milliseconds) between each HTTP request, used for <code>Cannon.delay</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.delayInt = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Our definition of self.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <h2 id="exported-methods">Exported Methods</h2>

            </div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              
            </div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>The <code>Cannon.fire</code> method is used to activate the Cannon (i.e. make HTTP requests, parse data, etc). The data passed to the callback will be an array of data shaped by string passed to <code>Cannon.projectile</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.fire = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(callback)</span> {</span>
        self._fetch(callback);
        <span class="hljs-keyword">return</span> self;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>The <code>Cannon.reload</code> method is used for dealing with paginated content. It takes an object of reloader strings like <code>{after: &quot;data.after&quot;}</code> and stores it in the Cannon. After the initial URL provided to the Cannon is loaded, another URL will be loaded which has the added query data <code>?after={{data.after}}</code> with the value for <code>data.after</code> being pulled from the data for the first page. </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.reload = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(reloaderStrs)</span> {</span>
        self.reloaderStrs = reloaderStrs;
        <span class="hljs-keyword">return</span> self;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>The <code>Cannon.limit</code> method is used for limiting the number of HTTP requests when a reloader is used. Theoredically, a reloader could be used to load an infinite amount of pages, which may not be what we want. The <code>limit</code> method takes a number and will not let the total page requests from this Cannon exceed that number.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.limit = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(limit)</span> {</span>
        self.limitInt = limit;
        <span class="hljs-keyword">return</span> self;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>The <code>Cannon.delay</code> method is used for adding a delay between HTTP requests when a reloader is used. This method takes a number of millseconds and delays each HTTP request by that amount of time.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.delay = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(delayInt)</span> {</span>
        self.delayInt = delayInt;
        <span class="hljs-keyword">return</span> self;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>The <code>Cannon.projectile</code> method is used for defining the shape of the data passed to <code>Cannon.fire</code>&#39;s callback. An example <code>projectileStr</code> would be <code>&quot;data.children.*.data.title&quot;</code>. This tells the Cannon to fire the data in <code>dataFromURL[&#39;data&#39;][&#39;children&#39;][*][&#39;data&#39;][&#39;title&#39;]</code>. This syntax should be familiar to any developer with the exception of the special <code>*</code> field. This character is the single most important concept when building a Cannon. It acts as a wild card and allows us to get a list of titles from all the children, not just a specific one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.projectile = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(projectileStr)</span> {</span>
        self.projectileStr = projectileStr;
        <span class="hljs-keyword">return</span> self;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>The <code>Cannon.recoil</code> method is typically used from within the <code>Cannon.fire</code> callback. This method will take a single projectile and return the parent(s) of that projectile. For example, if we have our projectile set as <code>&quot;data.children.*.data.title&quot;</code>, then our projectile will be the value of <code>title</code>. In order to access the complete child&#39;s data, we can <code>Cannon.recoil</code> the <code>title</code> and we will receive the <code>data</code> object which has the <code>title</code> field. It is important to note that <em>this method returns a list of matches, not a single match</em> due to the fact that there is no guarantee that the projectile provided will be unique.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.recoil = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(projectile)</span> {</span>
        <span class="hljs-keyword">return</span> self._getField(self.rawData, self.projectileStr, projectile);
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <h2 id="internal-methods">Internal Methods</h2>

            </div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              
            </div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>The <code>Cannon._fetch</code> method is the gunpowder of the Cannon. It handles fetching URLs, reloading, and creating the final <code>projectileBlob</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._fetch = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(callback, projectileBlob, queryData)</span> {</span> 
        <span class="hljs-keyword">if</span> (self.limitInt &amp;&amp; self.fetches++ == self.limitInt) {
            callback(projectileBlob, self);
            <span class="hljs-keyword">return</span>;
        }
        
        queryData = queryData? queryData: {};
        
        <span class="hljs-keyword">var</span> handle = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> {</span>         
            self.rawData.push(data);
            <span class="hljs-keyword">var</span> projectilePartial = self._getField([data], self.projectileStr);
            
            <span class="hljs-keyword">if</span> (self._isArray(projectilePartial)) {
                <span class="hljs-keyword">if</span> (!projectileBlob) {
                    projectileBlob = [];   
                }
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> p = <span class="hljs-number">0</span>; p&lt;projectilePartial.length; p++) {
                    projectileBlob.push(projectilePartial[p]);   
                }
            }
            
            <span class="hljs-keyword">var</span> reloaders = {};
            <span class="hljs-keyword">var</span> hasReloader = <span class="hljs-literal">false</span>;
            
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> reloaderKey <span class="hljs-keyword">in</span> self.reloaderStrs) {
                <span class="hljs-keyword">var</span> reloader = self.reloaderStrs[reloaderKey];
                reloaders[reloaderKey] = self._getField([data], self.reloaderStrs[reloaderKey])[<span class="hljs-number">0</span>];  
                hasReloader = reloaders[reloaderKey] || hasReloader;
            }
            
            <span class="hljs-keyword">if</span> (hasReloader) {
                setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
                    self._fetch(callback, projectileBlob, reloaders);
                }, self.delayInt);
            }<span class="hljs-keyword">else</span>{
                callback(projectileBlob, self);
                <span class="hljs-keyword">return</span>;
            }
        };
        
        <span class="hljs-keyword">this</span>._getURL(self.url, queryData).then(handle);
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>The <code>Cannon._getField</code> method is the method used to parse and fetch data pased on a <code>projectileStr</code> (or <code>fieldStr</code>). This method takes an array of pools, a field string, and an optional target.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._getField = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(pools, fieldsStr, target)</span> {</span>
        <span class="hljs-keyword">var</span> fields = fieldsStr.split(<span class="hljs-string">'.'</span>);
        <span class="hljs-keyword">var</span> targets = [];
        
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> f=<span class="hljs-number">0</span>; f&lt;fields.length; f++) {
            <span class="hljs-keyword">var</span> field = fields[f];
            <span class="hljs-keyword">var</span> newPools = [];
            
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> p=<span class="hljs-number">0</span>; p&lt;pools.length; p++) {
                <span class="hljs-keyword">var</span> pool = pools[p];
                <span class="hljs-keyword">if</span> (field == <span class="hljs-string">"*"</span>) {
                    <span class="hljs-keyword">var</span> child;
                    <span class="hljs-keyword">if</span> (self._isArray(pools)) {
                        <span class="hljs-keyword">for</span> (child=<span class="hljs-number">0</span>; child&lt;pool.length; child++) {
                            newPools.push(pool[child]);
                            <span class="hljs-keyword">if</span> (pool[child] == target) {
                                targets.push(pool);
                            }
                        }
                    }
                    <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">for</span> (child <span class="hljs-keyword">in</span> pool) {
                            newPools.push(pool[child]);
                            <span class="hljs-keyword">if</span> (pool[child] == target) {
                                targets.push(pool);
                            }
                        }
                    }
                }
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pool[field]) {
                    newPools.push(pool[field]);
                    <span class="hljs-keyword">if</span> (pool[field] == target) {
                        targets.push(pool);
                    }
                }
            }
            pools = newPools;
        }
        
        <span class="hljs-keyword">if</span> (target) {
            <span class="hljs-keyword">return</span> targets;   
        }<span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">return</span> pools;
        }
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>The <code>Cannon._getURL</code> method is our XHR wrapper used for requesting data.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._getURL = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(src, data)</span> {</span>
        <span class="hljs-keyword">var</span> deferred = self._defer();
        <span class="hljs-keyword">var</span> queryPairs = [];
        <span class="hljs-keyword">var</span> queryString = <span class="hljs-string">""</span>;
        
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> field <span class="hljs-keyword">in</span> data) {
            queryPairs.push(field + <span class="hljs-string">"="</span> + data[field]);
        }
        
        <span class="hljs-keyword">if</span> (queryPairs.length) {
            queryString = <span class="hljs-string">"?"</span> + queryPairs.join(<span class="hljs-string">"&amp;"</span>);
        }
        
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reqListener</span> <span class="hljs-params">(res)</span> {</span>
            deferred.resolve(<span class="hljs-built_in">JSON</span>.parse(res.responseText || res.currentTarget.responseText));
        }
        
        <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();
        xhr.onload = reqListener;
        xhr.open(<span class="hljs-string">"get"</span>, src + queryString, <span class="hljs-literal">true</span>);
        xhr.send(); 
        
        <span class="hljs-keyword">return</span> deferred.promise;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>The <code>Cannon._defer</code> is a minimalist promise implemtation used in <code>Cannon._getURL</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._defer = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">var</span> local = {};
        
        local.promise = {
            then: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(callback)</span> {</span>
                local.callback = callback;
                <span class="hljs-keyword">if</span> (local.resolved) {
                    local.finish();
                }
            }
        };
        
        local.resolve = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
            local.args = <span class="hljs-built_in">arguments</span>;
            <span class="hljs-keyword">if</span> (local.callback) {
                local.finish();
            }
            local.resolved = <span class="hljs-literal">true</span>;
        };
        
        local.finish = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
            local.callback.apply(self, local.args);
        };
        
        <span class="hljs-keyword">return</span> local;
    };
    
    <span class="hljs-keyword">this</span>._isArray = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(obj)</span> {</span>
        <span class="hljs-keyword">return</span> toString.call(obj) == <span class="hljs-string">'[object Array]'</span>;        
    };
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
